//  
//  For more information, please see: http://software.sci.utah.edu
//  
//  The MIT License
//  
//  Copyright (c) 2009 Scientific Computing and Imaging Institute,
//  University of Utah.
//  
//  
//  Permission is hereby granted, free of charge, to any person obtaining a
//  copy of this software and associated documentation files (the "Software"),
//  to deal in the Software without restriction, including without limitation
//  the rights to use, copy, modify, merge, publish, distribute, sublicense,
//  and/or sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following conditions:
//  
//  The above copyright notice and this permission notice shall be included
//  in all copies or substantial portions of the Software.
//  
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
//  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
//  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//  
//    File   : InhomogeneityCorrectionFilter.cc
//    Author : Michael Callahan
//    Date   : May 2008

#include <Applications/Seg3D/InhomogeneityCorrectionFilter.h>
#include <Applications/Seg3D/Seg3DFrame.h>
#include <Applications/Seg3D/Painter.h>
#include <Applications/Seg3D/VolumeOps.h>
#include <Core/Util/Assert.h>

#include <sci_defs/insight_defs.h>
#include <itkDiscreteGaussianImageFilter.h>
#include <itkGradientImageFilter.h>
#include <itkGradientMagnitudeImageFilter.h>

namespace SCIRun {

const float log_epsilon = 0.01;



InhomogeneityCorrectionFilterTool::InhomogeneityCorrectionFilterTool(Painter *painter) :
  BaseTool("InhomogeneityCorrectionFilterTool::"),
  PointerTool("InhomogeneityCorrectionFilterTool::"),
  painter_(painter)
{
}


BaseTool::propagation_state_e 
InhomogeneityCorrectionFilterTool::process_event(event_handle_t event)
{ 
  // check for the FinishEvent signal generated by the start button
  if (dynamic_cast<FinishEvent *>(event.get_rep())) {
    if (!painter_->check_for_active_data_volume("Intensity correction filter"))
    {
      return STOP_E;
    }
	  
    run_filter();
  }
  return CONTINUE_E;
}


struct dinfo_type {
   int size_x;
   int size_y;
   int size_z;
   int m;
   int s;
   double xcenter;
   double ycenter;
   double zcenter;
   double xscale;
   double yscale;
   double zscale;
};


static double
getAx( double w, double nx, double ny, double nz, int order_index)
{
   double val = 0;
   switch( order_index ){

      case 0:
         val = w;
         break;

      /* order > 1 */
      case 3:
         val = w * 2.0 * nx;
         break;
      case 4:
         val = w * ny;
         break;
      case 5:
         val = w * nz;
         break;

      /* order > 2 */
      case 9:
         val = w * 3.0 * nx * nx;
         break;
      case 10:
         val = w * 2.0 * nx * ny;
         break;
      case 11:
         val = w * 2.0 * nx * nz;
         break;
      case 12:
         val = w * ny * ny;
         break;
      case 13:
         val = w * ny * nz;
         break;
      case 14:
         val = w * nz * nz;
         break;

      /* order > 3 */
      case 19:
         val = w * 4.0 * nx * nx * nx;
         break;
      case 20:
         val = w * 3.0 * nx * nx * ny;
         break;
      case 21:
         val = w * 3.0 * nx * nx * nz;
         break;
      case 22:
         val = w * 2.0 * nx * ny * ny;
         break;
      case 23:
         val = w * 2.0 * nx * ny * nz;
         break;
      case 24:
         val = w * 2.0 * nx * nz * nz;
         break;
      case 25:
         val = w * ny * ny * ny;
         break;
      case 26:
         val = w * ny * ny * nz;
         break;
      case 27:
         val = w * ny * nz * nz;
         break;
      case 28:
         val = w * nz * nz * nz;
         break;
      default:
         val = 0;
         break;
   }

   return val; 
}


static double
getAy( double w, double nx, double ny, double nz, int order_index)
{
   double val = 0;

   switch( order_index ){

      case 1:
         val = w;
         break;

      /* order > 1 */
      case 4:
         val = w * nx;
         break;
      case 6:
         val = w * 2.0 * ny;
         break;
      case 7:
         val = w * nz;
         break;

      /* order > 2 */
      case 10:
         val = w * nx * nx;
         break;
      case 12:
         val = w * 2.0 * nx * ny;
         break;
      case 13:
         val = w * nx * nz;
         break;
      case 15:
         val = w * 3.0 * ny * ny;
         break;
      case 16:
         val = w * 2.0 * ny * nz;
         break;
      case 17:
         val = w * nz * nz;
         break;

      /* order > 3 */   
      case 20:
         val = w * nx * nx * nx;
         break;
      case 22:
         val = w * 2.0 * nx * nx * ny;
         break;
      case 23:
         val = w * nx * nx * nz;
         break;
      case 25:
         val = w * 3.0 * ny * ny * nx;
         break;
      case 26:
         val = w * 2.0 * nx * ny * nz;
         break;
      case 27:
         val = w * nx * nz * nz;
         break;
      case 29:
         val = w * 4.0 * ny * ny * ny;
         break;
      case 30:
         val = w * 3.0 * ny * ny * nz;
         break;
      case 31:
         val = w * 2.0 * ny * nz * nz;
         break;
      case 32:
         val = w * nz * nz * nz;
         break;
      default:
         val = 0;
         break;
   }

   return val;
}


static double
getAz( double w, double nx, double ny, double nz, int order_index)
{
   double val = 0;

   switch( order_index ){

      case 2:
         val = w;
         break;

      /* order > 1 */
      case 5:
            val = w * nx;
            break;
      case 7:
            val = w * ny;
            break;
      case 8:
            val = w * 2.0 * nz;
            break;

      /* order > 2 */
      case 11:
            val = w * nx * nx;
            break;
      case 13:
            val = w * nx * ny;
            break;
      case 14:
            val = w * 2.0 * nx * nz;
            break;
      case 16:
            val = w * ny * ny;
            break;
      case 17:
            val = w * 2.0 * ny * nz;
            break;
      case 18:
            val = w * 3.0 * nz * nz;
            break;

      /* order > 3 */
      case 21:
            val = w * nx * nx * nx;
            break;
      case 23:
            val = w * nx * nx * ny;
            break;
      case 24:
            val = w * 2.0 * nx * nx * nz;
            break;
      case 26:
            val = w * nx * ny * ny;
            break;
      case 27:
            val = w * 2.0 * nx * ny * nz;
            break;
      case 28:
            val = w * 3.0 * nx * nz * nz;
            break;
      case 30:
            val = w * ny * ny * ny;
            break;
      case 31:
            val = w * 2.0 * ny * ny * nz;
            break;
      case 32:
            val = w * 3.0 * ny * nz * nz;
            break;
      case 33:
            val = w * 4.0 * nz * nz * nz;
            break;
      default:
            val = 0;
            break;
   }

   return val;
}


void
InhomogeneityCorrectionFilterTool::run_filter()
{
  painter_->set_status("Running inhomogeneity correction filter.");

  NrrdVolumeHandle src_vol = painter_->current_volume_;

  // Grab the source volume sizes.
  NrrdDataHandle src_nrrd = src_vol->nrrd_handle_;
  size_t src_size = VolumeOps::nrrd_elem_count(src_nrrd);
  float *src_ptr = (float *)src_nrrd->nrrd_->data;
  const float datamin = Min(src_vol->data_min_, 0.0);

  dinfo_type di;
  di.size_x = src_nrrd->nrrd_->axis[1].size;
  di.size_y = src_nrrd->nrrd_->axis[2].size;
  di.size_z = src_nrrd->nrrd_->axis[3].size;
  di.m = di.size_x * di.size_y * di.size_z;
  di.s = di.m * 3;
  di.xcenter = di.size_x / 2.0;
  di.ycenter = di.size_y / 2.0;
  di.zcenter = di.size_z / 2.0;
  di.xscale = (di.size_x + di.size_y + di.size_z) / 2.0 / 4.0;
  di.yscale = (di.size_x + di.size_y + di.size_z) / 2.0 / 4.0;
  di.zscale = (di.size_x + di.size_y + di.size_z) / 2.0 / 4.0;

  NrrdVolumeHandle log_vol = painter_->copy_current_layer(" IC");

  painter_->set_status("Running intensity correction filter.");
  painter_->start_progress();

  // Discrete gaussian blur of the image first to reduce noise.
  // TODO:  Add median filter, no blur options.
  typedef itk::DiscreteGaussianImageFilter< ITKImageFloat3D, ITKImageFloat3D > DGFilterType;
  DGFilterType::Pointer dgfilter = DGFilterType::New();
  ITKDatatypeHandle itk_dg_image_h =
    nrrd_to_itk_image(log_vol->nrrd_handle_);
  ITKImageFloat3D *itkdgimg =
    dynamic_cast<ITKImageFloat3D *>(itk_dg_image_h->data_.GetPointer());
  dgfilter->SetInput(itkdgimg);
  dgfilter->SetVariance(1.0);
  dgfilter->SetMaximumKernelWidth(8);
  dgfilter->SetUseImageSpacingOff();
  dgfilter->Update();
  SCIRun::ITKDatatypeHandle output1_img = new SCIRun::ITKDatatype();
  output1_img->data_ = dgfilter->GetOutput();
  log_vol->nrrd_handle_ = itk_image_to_nrrd<float, 3>(output1_img);

  painter_->update_progress(5);

  // Take the log of the source image (add 0.01 first so log is stable).
  NrrdDataHandle log_nrrd = log_vol->nrrd_handle_;
  float *log_ptr = (float *)log_nrrd->nrrd_->data;
  for (size_t i = 0; i < src_size; i++)
  {
    log_ptr[i] = log(log_ptr[i] + log_epsilon - datamin);
  }
  painter_->current_volume_->reset_data_range();

  painter_->update_progress(10);

  // Take the Gradient Magnitude of the log image.
  typedef itk::GradientMagnitudeImageFilter< ITKImageFloat3D, ITKImageFloat3D > GMagFilterType;
  GMagFilterType::Pointer gmag_filter = GMagFilterType::New();
  ITKDatatypeHandle itk_gmag_image_h =
    nrrd_to_itk_image(painter_->current_volume_->nrrd_handle_);
  ITKImageFloat3D *itkgmagimg =
    dynamic_cast<ITKImageFloat3D *>(itk_gmag_image_h->data_.GetPointer());
  gmag_filter->SetInput(itkgmagimg);
  gmag_filter->Update();
  SCIRun::ITKDatatypeHandle output_img = new SCIRun::ITKDatatype();
  output_img->data_ = gmag_filter->GetOutput();
  NrrdDataHandle W_nrrd = itk_image_to_nrrd<float, 3>(output_img);

  painter_->update_progress(15);

  // Compute the weighted edge image.
  size_t W_size = VolumeOps::nrrd_elem_count(W_nrrd);
  float *W = (float *)W_nrrd->nrrd_->data;
  const double mu =
    painter_->get_vars()->get_double("Painter::IntensityCorrection::edge");
  const float oomu2 = 1.0 / (mu * mu);
  for (size_t i = 0; i < W_size; i++)
  {
    W[i] = exp ( - W[i] * oomu2);
  }

  painter_->update_progress(20);

  // Compute the gradient image.
  typedef itk::GradientImageFilter<ITKImageFloat3D> GradientFilterType;
  typedef GradientFilterType::OutputImageType GradientImageType;
  typedef GradientImageType::PixelType GradientPixelType;

  GradientFilterType::Pointer gradient_filter = GradientFilterType::New();
  ITKDatatypeHandle itk_image_h = nrrd_to_itk_image(log_nrrd);
  ITKImageFloat3D *itkimg =
    dynamic_cast<ITKImageFloat3D *>(itk_image_h->data_.GetPointer());
  gradient_filter->SetInput(itkimg);
  gradient_filter->Update();
  GradientImageType::Pointer gradient_image = gradient_filter->GetOutput();

  painter_->update_progress(25);

  // Create the matrices.

  // Build F (U?)
  // Note:  Float matrix args?
  vnl_matrix< double > U( di.s, 1, 0.0 );
  typedef itk::ImageRegionIterator< GradientImageType > GradientImageIterator;
  GradientImageIterator grad_iter(gradient_image,
                                  gradient_image->GetLargestPossibleRegion());
  size_t j = 0;
  while (!grad_iter.IsAtEnd())
  {
    GradientPixelType v = grad_iter.Get();
    // NOTE:  W[j] is 'exp ( - v.GetNorm() * oomu2)' here.

    U[j         ][0] = W[j] * v[0] * di.xscale;
    U[j + di.m  ][0] = W[j] * v[1] * di.yscale;
    U[j + 2*di.m][0] = W[j] * v[2] * di.zscale;

    ++j;
    ++grad_iter;
  }
  
  // Build A
  const int order_arg = painter_->get_vars()->get_int("Painter::IntensityCorrection::order");
  static int order_counts[5] = { 0, 3, 9, 19, 34 };
  const int order = order_counts[order_arg];
  vnl_matrix<double> ATA(order, order, 0);
  vnl_matrix<double> uT(order, 1, 0);

  //
  //  loop over all the pixels in the image and calculate ATA in-place.
  //
  for( int z = 0; z < di.size_z; z++)
  {
    const int progress = 30 + (int)((z / (double)di.size_z) * 70.0);
    painter_->update_progress(progress);
    for (int y = 0; y < di.size_y; y++)
    {
      for (int x = 0; x < di.size_x; x++)
      {
        const double nx = (x - di.xcenter) / di.xscale;
        const double ny = (y - di.ycenter) / di.yscale;
        const double nz = (z - di.zcenter) / di.zscale;

        const int row_num = 
          ( (di.size_x * di.size_y * z) + (di.size_x * y) + x);
        const double w = W[row_num];

        for( int i = 0; i < order; i++ )
        {
          for( int j = 0; j < order; j++ )
          {
            double val = ATA(i, j);

            const double ax = getAx( w, nx, ny, nz, j);
            const double axt = getAx( w, nx, ny, nz, i);

            val += ax * axt;

            const double ay = getAy( w, nx, ny, nz, j);
            const double ayt = getAy( w, nx, ny, nz, i);

            val += ay * ayt;

            const double az = getAz( w, nx, ny, nz, j);
            const double azt = getAz( w, nx, ny, nz, i);

            val += az * azt;

            if( j == 0 ) // only need to do this once
            {
              double u_val = uT( i, 0 );
              const int h = di.size_x * di.size_y * z + di.size_x * y + x;
              u_val += ( axt * U( h, 0 ) ) +
                ( ayt * U( h + di.m, 0 ) ) +
                ( azt * U( h + (2 * di.m), 0 ) );
              uT( i, 0 ) = u_val;

            }

            ATA(i, j) = val;
          }
        }
      }
    }
  }

  vnl_matrix< double > ATA_inv = vnl_matrix_inverse<double>(ATA);
  vnl_matrix< double > alphaM = ATA_inv * uT;
  vnl_vector< double > alpha = alphaM.get_column(0);

  // Create the source - illumination field.
  size_t i = 0;
  for (int z = 0; z < di.size_z; z++)
  {
    for (int y = 0; y < di.size_y; y++)
    {
      for (int x = 0; x < di.size_x; x++)
      {
        const double nx = (x - di.xcenter) / di.xscale;
        const double ny = (y - di.ycenter) / di.yscale;
        const double nz = (z - di.zcenter) / di.zscale;

        double val =
          alpha[0] * nx +
          alpha[1] * ny +
          alpha[2] * nz;

        if (order_arg > 1)
        {
          val +=
            alpha[3] * nx * nx +
            alpha[4] * nx * ny +
            alpha[5] * nx * nz +
            alpha[6] * ny * ny +
            alpha[7] * ny * nz +
            alpha[8] * nz * nz;

          if (order_arg > 2)
          {
            val +=
              alpha[9] * nx * nx * nx +
              alpha[10] * nx * nx * ny +
              alpha[11] * nx * nx * nz +
              alpha[12] * nx * ny * ny +
              alpha[13] * nx * ny * nz +
              alpha[14] * nx * nz * nz +
              alpha[15] * ny * ny * ny +
              alpha[16] * ny * ny * nz +
              alpha[17] * ny * nz * nz +
              alpha[18] * nz * nz * nz;
         
            if (order_arg > 3)
            {
              val +=
                alpha[19] * nx * nx * nx * nx +
                alpha[20] * nx * nx * nx * ny +
                alpha[21] * nx * nx * nx * nz +
                alpha[22] * nx * nx * ny * ny +
                alpha[23] * nx * nx * ny * nz +
                alpha[24] * nx * nx * nz * nz +
                alpha[25] * nx * ny * ny * ny +
                alpha[26] * nx * ny * ny * nz +
                alpha[27] * nx * ny * nz * nz +
                alpha[28] * nx * nz * nz * nz +
                alpha[29] * ny * ny * ny * ny +
                alpha[30] * ny * ny * ny * nz +
                alpha[31] * ny * ny * nz * nz +
                alpha[32] * ny * nz * nz * nz +
                alpha[33] * nz * nz * nz * nz;
            }
          }
        }
        W[i] = exp(val);
        log_ptr[i] = (src_ptr[i] - datamin) * exp(-val) + datamin;
        i++;
      }
    }
  }
  log_vol->reset_data_range();

  UndoHandle undo =
    new UndoReplaceLayer(painter_, "Undo Intensity Correction",
                         0, painter_->current_volume_, 0);
  painter_->push_undo(undo);

  painter_->finish_progress();

  painter_->extract_all_window_slices();
  painter_->redraw_all();

  painter_->hide_tool_panel();
}


}
